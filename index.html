<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TVBOX配置转图片工具 - 支持自定义背景</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .wrapper {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    h2 {
      color: #333;
      text-align: center;
      margin-bottom: 20px;
    }
    .inner {
      display: flex;
      gap: 20px;
    }
    .textarea-group {
      flex: 1;
    }
    .input-group {
      width: 300px;
    }
    textarea {
      width: 100%;
      height: 400px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: none;
      font-family: monospace;
    }
    .form-control {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    input[type="text"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .btn-group {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    button {
      padding: 8px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    .btn-encrypt {
      background-color: #28a745;
      color: white;
    }
    .btn-decrypt {
      background-color: #007bff;
      color: white;
    }
    .btn-upload {
      background-color: #6c757d;
      color: white;
    }
    .btn-download {
      background-color: #17a2b8;
      color: white;
    }
    .btn-img {
      background-color: #ffc107;
      color: black;
    }
    .checkbox-group {
      margin-bottom: 15px;
    }
    select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 15px;
    }
    .file-input {
      display: none;
    }
    #imagePreview {
      max-width: 100%;
      margin-top: 10px;
      display: none;
    }
    #bgImagePreview {
      max-width: 100%;
      margin-top: 10px;
      display: none;
    }
    .option-group {
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h2>TVBOX配置转图片工具 - 支持自定义背景</h2>
    <div class="inner">
      <div class="textarea-group">
        <textarea id="inputText" placeholder="请输入要转换的配置内容"></textarea>
      </div>
      <div class="input-group">
        <div class="form-control">
          <label for="key">KEY/密码（加密时使用）</label>
          <input type="text" id="key" value="123456" maxlength="16">
        </div>
        
        <div class="form-control">
          <label for="iv">IV/向量（加密时使用）</label>
          <input type="text" id="iv" value="" maxlength="13">
        </div>
        
        <div class="option-group">
          <label>转换方式</label>
          <select id="convertMethod">
            <option value="text">文字叠加（直接显示）</option>
            <option value="qr">生成二维码嵌入</option>
            <option value="stegano">隐形水印（需解密）</option>
          </select>
        </div>
        
        <div class="btn-group">
          <button class="btn-upload" id="uploadBgBtn">上传背景图片</button>
          <input type="file" id="bgImageInput" accept="image/*" class="file-input">
        </div>
        
        <div class="btn-group">
          <button class="btn-img" id="toImgBtn">生成配置图片</button>
          <button class="btn-img" id="fromImgBtn">从图片读取配置</button>
          <input type="file" id="imgInput" accept="image/*" class="file-input">
        </div>
        
        <div id="bgPreviewContainer">
          <p>背景预览：</p>
          <img id="bgImagePreview" alt="背景图片预览">
        </div>
        
        <div id="resultPreviewContainer">
          <p>生成结果：</p>
          <img id="imagePreview" alt="配置图片预览">
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // 初始化IV为当前时间戳
      document.getElementById('iv').value = new Date().getTime();
      
      let bgImageData = null;
      
      // 上传背景图片
      document.getElementById('uploadBgBtn').addEventListener('click', function() {
        document.getElementById('bgImageInput').click();
      });
      
      document.getElementById('bgImageInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
          bgImageData = e.target.result;
          const imgPreview = document.getElementById('bgImagePreview');
          imgPreview.src = bgImageData;
          imgPreview.style.display = 'block';
        };
        reader.readAsDataURL(file);
      });
      
      // 生成配置图片
      document.getElementById('toImgBtn').addEventListener('click', function() {
        const text = document.getElementById('inputText').value.trim();
        if (!text) {
          alert('请输入要转换的配置内容');
          return;
        }
        
        const method = document.getElementById('convertMethod').value;
        
        if (method === 'qr') {
          generateQRCodeImage(text);
        } else if (method === 'stegano') {
          generateSteganoImage(text);
        } else {
          generateTextImage(text);
        }
      });
      
      // 从图片读取配置
      document.getElementById('fromImgBtn').addEventListener('click', function() {
        document.getElementById('imgInput').click();
      });
      
      document.getElementById('imgInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const method = document.getElementById('convertMethod').value;
        
        if (method === 'qr') {
          readQRCodeFromImage(file);
        } else if (method === 'stegano') {
          readSteganoFromImage(file);
        } else {
          readTextFromImage(file);
        }
      });
      
      // 生成带文字的图片
      function generateTextImage(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // 如果有背景图片，使用背景图片
        if (bgImageData) {
          const img = new Image();
          img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            drawTextOnCanvas(ctx, canvas.width, canvas.height, text);
            finalizeImage(canvas);
          };
          img.src = bgImageData;
        } else {
          // 没有背景图片，创建纯色背景
          canvas.width = 800;
          canvas.height = Math.max(600, Math.ceil(text.length / 60) * 30);
          ctx.fillStyle = '#f8f9fa';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          drawTextOnCanvas(ctx, canvas.width, canvas.height, text);
          finalizeImage(canvas);
        }
      }
      
      // 在画布上绘制文本
      function drawTextOnCanvas(ctx, width, height, text) {
        const fontSize = Math.max(12, Math.min(24, width / 50));
        const lineHeight = fontSize * 1.5;
        const margin = 30;
        const maxLineWidth = width - margin * 2;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.font = `bold ${fontSize}px Arial`;
        ctx.textBaseline = 'top';
        
        // 自动换行
        const lines = [];
        let currentLine = '';
        
        for (const word of text.split(' ')) {
          const testLine = currentLine ? `${currentLine} ${word}` : word;
          const metrics = ctx.measureText(testLine);
          
          if (metrics.width <= maxLineWidth || !currentLine) {
            currentLine = testLine;
          } else {
            lines.push(currentLine);
            currentLine = word;
          }
        }
        
        if (currentLine) lines.push(currentLine);
        
        // 绘制文本
        lines.forEach((line, i) => {
          const y = margin + i * lineHeight;
          // 文字阴影效果
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillText(line, margin + 2, y + 2);
          ctx.fillStyle = 'white';
          ctx.fillText(line, margin, y);
        });
      }
      
      // 生成二维码图片
      function generateQRCodeImage(text) {
        const canvas = document.createElement('canvas');
        
        // 如果有背景图片，调整二维码大小
        const size = bgImageData ? 200 : 400;
        
        QRCode.toCanvas(canvas, text, { width: size }, function(error) {
          if (error) {
            alert('生成二维码失败: ' + error);
            return;
          }
          
          if (bgImageData) {
            // 把二维码放到背景图片上
            const compositeCanvas = document.createElement('canvas');
            const ctx = compositeCanvas.getContext('2d');
            
            const bgImg = new Image();
            bgImg.onload = function() {
              compositeCanvas.width = bgImg.width;
              compositeCanvas.height = bgImg.height;
              ctx.drawImage(bgImg, 0, 0);
              
              // 把二维码放在右下角
              const qrX = bgImg.width - size - 20;
              const qrY = bgImg.height - size - 20;
              
              // 半透明背景
              ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
              ctx.fillRect(qrX - 10, qrY - 10, size + 20, size + 20);
              
              ctx.drawImage(canvas, qrX, qrY);
              finalizeImage(compositeCanvas);
            };
            bgImg.src = bgImageData;
          } else {
            finalizeImage(canvas);
          }
        });
      }
      
      // 生成隐形水印图片（简单版）
      function generateSteganoImage(text) {
        if (!bgImageData) {
          alert('隐形水印需要背景图片');
          return;
        }
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const img = new Image();
        img.onload = function() {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          
          // 简单的水印算法：修改LSB（最低有效位）
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          const textBits = stringToBits(text);
          let bitIndex = 0;
          
          for (let i = 0; i < data.length; i += 4) {
            if (bitIndex < textBits.length) {
              // 只修改RGB通道，不修改Alpha通道
              for (let j = 0; j < 3; j++) {
                if (bitIndex < textBits.length) {
                  // 清除最低位，然后设置为我们想要的位
                  data[i + j] = (data[i + j] & 0xFE) | parseInt(textBits[bitIndex]);
                  bitIndex++;
                }
              }
            } else {
              break;
            }
          }
          
          ctx.putImageData(imageData, 0, 0);
          finalizeImage(canvas);
        };
        img.src = bgImageData;
      }
      
      // 从图片读取文本
      function readTextFromImage(file) {
        alert('从图片读取文本功能需要OCR支持，请使用二维码或隐形水印方式');
      }
      
      // 从二维码读取配置
      function readQRCodeFromImage(file) {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = function(e) {
          img.src = e.target.result;
          
          img.onload = function() {
            // 使用QRCode.js解码
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            // 简化版：实际应该使用更健壮的二维码解码库
            try {
              const result = QRCode.decodeFromImage(img);
              document.getElementById('inputText').value = result;
              alert('成功读取二维码内容');
            } catch (err) {
              alert('无法识别二维码: ' + err.message);
            }
          };
        };
        
        reader.readAsDataURL(file);
      }
      
      // 从隐形水印读取配置
      function readSteganoFromImage(file) {
        const img = new Image();
        const reader = new FileReader();
        
        reader.onload = function(e) {
          img.src = e.target.result;
          
          img.onload = function() {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const bits = [];
            
            // 提取LSB
            for (let i = 0; i < data.length; i += 4) {
              for (let j = 0; j < 3; j++) {
                bits.push(data[i + j] & 1);
              }
            }
            
            const text = bitsToString(bits);
            document.getElementById('inputText').value = text;
          };
        };
        
        reader.readAsDataURL(file);
      }
      
      // 最终处理生成的图片
      function finalizeImage(canvas) {
        const dataUrl = canvas.toDataURL('image/png');
        const imgPreview = document.getElementById('imagePreview');
        imgPreview.src = dataUrl;
        imgPreview.style.display = 'block';
        
        // 提供下载
        const link = document.createElement('a');
        link.href = dataUrl;
        link.download = 'tvbox_config.png';
        link.click();
      }
      
      // 工具函数：字符串转二进制位
      function stringToBits(str) {
        const bits = [];
        for (let i = 0; i < str.length; i++) {
          const charCode = str.charCodeAt(i);
          for (let j = 7; j >= 0; j--) {
            bits.push((charCode >> j) & 1);
          }
        }
        // 添加结束标记
        bits.push(0, 0, 0, 0, 0, 0, 0, 0);
        return bits;
      }
      
      // 工具函数：二进制位转字符串
      function bitsToString(bits) {
        let str = '';
        for (let i = 0; i < bits.length; i += 8) {
          if (i + 8 > bits.length) break;
          
          let charCode = 0;
          for (let j = 0; j < 8; j++) {
            charCode = (charCode << 1) | bits[i + j];
          }
          
          if (charCode === 0) break; // 结束标记
          str += String.fromCharCode(charCode);
        }
        return str;
      }
    });
  </script>
</body>
</html>